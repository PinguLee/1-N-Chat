소켓 프로그래밍 (TCP/IP) 학습을 위해 C로 간단한 1:n 채팅을 구현했습니다.

클라이언트는 window 환경이라 winsock api를 사용하였습니다.
과정은 아래와 같습니다.
윈속 초기화 -> ( 소켓 생성 -> 연결 -> 데이터 송수신 -> 소켓 종료 ) -> 윈속 종료

TCP 연결의 특성을 눈으로 보게 된 작업이었습니다.
TCP는 연결 지향형 프로토콜이기 떄문에 클라<->서버 간 연결이 성공적으로 설정된 후에야 데이터를 송수신할 수 있습니다.

이 작업으로 알게된 사실은 아래와 같습니다.
1. 버퍼 : 데이터를 임시로 저장하는 메모리 공간 (네트워크에서 데이터를 전송할때 일정량을 모아 전속하는 역할을 함)
2. htons() 호스트 바이트 순서로 포트번호를 변환하는 이유 : 네트워크 통신에서는 서로 다른 시스템 간의 데이터 전송이 이루어집니다. 이때 시스템들이 각각 다른 바이트 순서를 사용할 수 있기 때문에 데이터의 정확한 해석을 보장하기 위해 네트워크 바이트 순서라는 표준을 사용합니다. 만약 시스템 A가 리틀 엔디언 방식으로 데이터를 저장하고, 시스템 B가 빅 엔디언 방식으로 데이터를 저장한다면, 데이터를 전송할 때 데이터의 순서가 달라져서 올바르게 해석되지 않을 수 있습니다. htons는 포트 번호(정수) 값을 호스트 바이트에서 네트워크 바이트로 변환해줍니다.

TCP IP는 데이터 전송 시 빅엔디언을 사용하기 때문에 htons로 빅엔디언으로 바꿔주는 작업이라 생각하면 됩니다.
이외 아래와 같은 함수가 있는 듯

htons(): 호스트 바이트 순서에서 네트워크 바이트 순서로 16비트 값을 변환

htonl(): 호스트 바이트 순서에서 네트워크 바이트 순서로 32비트 값을 변환

ntohs(): 네트워크 바이트 순서에서 호스트 바이트 순서로 16비트 값을 변환

ntohl(): 네트워크 바이트 순서에서 호스트 바이트 순서로 32비트 값을 변환


3. 빅 엔디언 : 숫자의 가장 큰 바이트(Most Significant Byte, MSB)를 메모리의 가장 작은 주소(앞쪽)에 저장하는 방식 (0x12345678 -> 78 56 34 12 로 저장됨)
4. 리틀 엔디언 : 숫자의 가장 작은 바이트(Least Significant Byte, LSB)를 메모리의 가장 작은 주소(앞쪽)에 저장하는 방식 (0x12345678 -> 12 34 56 78 로 저장됨)

알아가야 할 상식을 정리해보았습니다.
IPv4, IPv6 사용 의미 : 기존엔 단순히 IPv4 주소 고갈 문제만으로 IPv6로 대체하려는 줄 알았으나 더 심화적인 개념을 습득할 필요가 있음(IPv4가 아직까지 주류인 이유 등)
